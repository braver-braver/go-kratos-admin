// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package generated

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"kratos-admin/app/admin/service/internal/data/gormcli/model"
)

func newSysPosition(db *gorm.DB) sysPosition {
	_sysPosition := sysPosition{}

	_sysPosition.sysPositionDo.UseDB(db)
	_sysPosition.sysPositionDo.UseModel(&model.SysPosition{})

	tableName := _sysPosition.sysPositionDo.TableName()
	_sysPosition.ALL = field.NewAsterisk(tableName)
	_sysPosition.ID = field.NewInt64(tableName, "id")
	_sysPosition.CreatedAt = field.NewTime(tableName, "created_at")
	_sysPosition.UpdatedAt = field.NewTime(tableName, "updated_at")
	_sysPosition.DeletedAt = field.NewField(tableName, "deleted_at")
	_sysPosition.CreatedBy = field.NewInt64(tableName, "created_by")
	_sysPosition.UpdatedBy = field.NewInt64(tableName, "updated_by")
	_sysPosition.DeletedBy = field.NewInt64(tableName, "deleted_by")
	_sysPosition.SortOrder = field.NewInt32(tableName, "sort_order")
	_sysPosition.Remark = field.NewString(tableName, "remark")
	_sysPosition.TenantID = field.NewInt64(tableName, "tenant_id")
	_sysPosition.Name = field.NewString(tableName, "name")
	_sysPosition.Code = field.NewString(tableName, "code")
	_sysPosition.OrganizationID = field.NewInt64(tableName, "organization_id")
	_sysPosition.DepartmentID = field.NewInt64(tableName, "department_id")
	_sysPosition.Status = field.NewString(tableName, "status")
	_sysPosition.Description = field.NewString(tableName, "description")
	_sysPosition.Quota = field.NewInt64(tableName, "quota")
	_sysPosition.ParentID = field.NewInt64(tableName, "parent_id")

	_sysPosition.fillFieldMap()

	return _sysPosition
}

type sysPosition struct {
	sysPositionDo

	ALL            field.Asterisk
	ID             field.Int64  // id
	CreatedAt      field.Time   // 创建时间
	UpdatedAt      field.Time   // 更新时间
	DeletedAt      field.Field  // 删除时间
	CreatedBy      field.Int64  // 创建者ID
	UpdatedBy      field.Int64  // 更新者ID
	DeletedBy      field.Int64  // 删除者ID
	SortOrder      field.Int32  // 排序顺序，值越小越靠前
	Remark         field.String // 备注
	TenantID       field.Int64  // 租户ID
	Name           field.String // 职位名称
	Code           field.String // 唯一编码
	OrganizationID field.Int64  // 所属组织ID
	DepartmentID   field.Int64  // 所属部门ID
	Status         field.String // 职位状态
	Description    field.String // 职能描述
	Quota          field.Int64  // 编制人数
	ParentID       field.Int64  // 父节点ID

	fieldMap map[string]field.Expr
}

func (s sysPosition) Table(newTableName string) *sysPosition {
	s.sysPositionDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sysPosition) As(alias string) *sysPosition {
	s.sysPositionDo.DO = *(s.sysPositionDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sysPosition) updateTableName(table string) *sysPosition {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.DeletedAt = field.NewField(table, "deleted_at")
	s.CreatedBy = field.NewInt64(table, "created_by")
	s.UpdatedBy = field.NewInt64(table, "updated_by")
	s.DeletedBy = field.NewInt64(table, "deleted_by")
	s.SortOrder = field.NewInt32(table, "sort_order")
	s.Remark = field.NewString(table, "remark")
	s.TenantID = field.NewInt64(table, "tenant_id")
	s.Name = field.NewString(table, "name")
	s.Code = field.NewString(table, "code")
	s.OrganizationID = field.NewInt64(table, "organization_id")
	s.DepartmentID = field.NewInt64(table, "department_id")
	s.Status = field.NewString(table, "status")
	s.Description = field.NewString(table, "description")
	s.Quota = field.NewInt64(table, "quota")
	s.ParentID = field.NewInt64(table, "parent_id")

	s.fillFieldMap()

	return s
}

func (s *sysPosition) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sysPosition) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 18)
	s.fieldMap["id"] = s.ID
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["deleted_at"] = s.DeletedAt
	s.fieldMap["created_by"] = s.CreatedBy
	s.fieldMap["updated_by"] = s.UpdatedBy
	s.fieldMap["deleted_by"] = s.DeletedBy
	s.fieldMap["sort_order"] = s.SortOrder
	s.fieldMap["remark"] = s.Remark
	s.fieldMap["tenant_id"] = s.TenantID
	s.fieldMap["name"] = s.Name
	s.fieldMap["code"] = s.Code
	s.fieldMap["organization_id"] = s.OrganizationID
	s.fieldMap["department_id"] = s.DepartmentID
	s.fieldMap["status"] = s.Status
	s.fieldMap["description"] = s.Description
	s.fieldMap["quota"] = s.Quota
	s.fieldMap["parent_id"] = s.ParentID
}

func (s sysPosition) clone(db *gorm.DB) sysPosition {
	s.sysPositionDo.ReplaceDB(db)
	return s
}

type sysPositionDo struct{ gen.DO }

type ISysPositionDo interface {
	gen.SubQuery
	Debug() ISysPositionDo
	WithContext(ctx context.Context) ISysPositionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISysPositionDo
	Not(conds ...gen.Condition) ISysPositionDo
	Or(conds ...gen.Condition) ISysPositionDo
	Select(conds ...field.Expr) ISysPositionDo
	Where(conds ...gen.Condition) ISysPositionDo
	Order(conds ...field.Expr) ISysPositionDo
	Distinct(cols ...field.Expr) ISysPositionDo
	Omit(cols ...field.Expr) ISysPositionDo
	Join(table schema.Tabler, on ...field.Expr) ISysPositionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISysPositionDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISysPositionDo
	Group(cols ...field.Expr) ISysPositionDo
	Having(conds ...gen.Condition) ISysPositionDo
	Limit(limit int) ISysPositionDo
	Offset(offset int) ISysPositionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISysPositionDo
	Unscoped() ISysPositionDo
	Create(values ...*model.SysPosition) error
	CreateInBatches(values []*model.SysPosition, batchSize int) error
	Save(values ...*model.SysPosition) error
	First() (*model.SysPosition, error)
	Take() (*model.SysPosition, error)
	Last() (*model.SysPosition, error)
	Find() ([]*model.SysPosition, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysPosition, err error)
	FindInBatches(result *[]*model.SysPosition, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SysPosition) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISysPositionDo
	Assign(attrs ...field.AssignExpr) ISysPositionDo
	Joins(fields ...field.RelationField) ISysPositionDo
	Preload(fields ...field.RelationField) ISysPositionDo
	FirstOrInit() (*model.SysPosition, error)
	FirstOrCreate() (*model.SysPosition, error)
	FindByPage(offset int, limit int) (result []*model.SysPosition, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISysPositionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s sysPositionDo) Debug() ISysPositionDo {
	return s.withDO(s.DO.Debug())
}

func (s sysPositionDo) WithContext(ctx context.Context) ISysPositionDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sysPositionDo) ReadDB() ISysPositionDo {
	return s.Clauses(dbresolver.Read)
}

func (s sysPositionDo) WriteDB() ISysPositionDo {
	return s.Clauses(dbresolver.Write)
}

func (s sysPositionDo) Clauses(conds ...clause.Expression) ISysPositionDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sysPositionDo) Returning(value interface{}, columns ...string) ISysPositionDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sysPositionDo) Not(conds ...gen.Condition) ISysPositionDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sysPositionDo) Or(conds ...gen.Condition) ISysPositionDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sysPositionDo) Select(conds ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sysPositionDo) Where(conds ...gen.Condition) ISysPositionDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sysPositionDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ISysPositionDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s sysPositionDo) Order(conds ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sysPositionDo) Distinct(cols ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sysPositionDo) Omit(cols ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sysPositionDo) Join(table schema.Tabler, on ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sysPositionDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sysPositionDo) RightJoin(table schema.Tabler, on ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sysPositionDo) Group(cols ...field.Expr) ISysPositionDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sysPositionDo) Having(conds ...gen.Condition) ISysPositionDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sysPositionDo) Limit(limit int) ISysPositionDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sysPositionDo) Offset(offset int) ISysPositionDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sysPositionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISysPositionDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sysPositionDo) Unscoped() ISysPositionDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sysPositionDo) Create(values ...*model.SysPosition) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sysPositionDo) CreateInBatches(values []*model.SysPosition, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sysPositionDo) Save(values ...*model.SysPosition) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sysPositionDo) First() (*model.SysPosition, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysPosition), nil
	}
}

func (s sysPositionDo) Take() (*model.SysPosition, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysPosition), nil
	}
}

func (s sysPositionDo) Last() (*model.SysPosition, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysPosition), nil
	}
}

func (s sysPositionDo) Find() ([]*model.SysPosition, error) {
	result, err := s.DO.Find()
	return result.([]*model.SysPosition), err
}

func (s sysPositionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysPosition, err error) {
	buf := make([]*model.SysPosition, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sysPositionDo) FindInBatches(result *[]*model.SysPosition, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sysPositionDo) Attrs(attrs ...field.AssignExpr) ISysPositionDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sysPositionDo) Assign(attrs ...field.AssignExpr) ISysPositionDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sysPositionDo) Joins(fields ...field.RelationField) ISysPositionDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sysPositionDo) Preload(fields ...field.RelationField) ISysPositionDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sysPositionDo) FirstOrInit() (*model.SysPosition, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysPosition), nil
	}
}

func (s sysPositionDo) FirstOrCreate() (*model.SysPosition, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysPosition), nil
	}
}

func (s sysPositionDo) FindByPage(offset int, limit int) (result []*model.SysPosition, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sysPositionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sysPositionDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sysPositionDo) Delete(models ...*model.SysPosition) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sysPositionDo) withDO(do gen.Dao) *sysPositionDo {
	s.DO = *do.(*gen.DO)
	return s
}
