// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package generated

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"kratos-admin/app/admin/service/internal/data/gormcli/model"
)

func newSysUserCredential(db *gorm.DB) sysUserCredential {
	_sysUserCredential := sysUserCredential{}

	_sysUserCredential.sysUserCredentialDo.UseDB(db)
	_sysUserCredential.sysUserCredentialDo.UseModel(&model.SysUserCredential{})

	tableName := _sysUserCredential.sysUserCredentialDo.TableName()
	_sysUserCredential.ALL = field.NewAsterisk(tableName)
	_sysUserCredential.ID = field.NewInt64(tableName, "id")
	_sysUserCredential.CreatedAt = field.NewTime(tableName, "created_at")
	_sysUserCredential.UpdatedAt = field.NewTime(tableName, "updated_at")
	_sysUserCredential.DeletedAt = field.NewField(tableName, "deleted_at")
	_sysUserCredential.TenantID = field.NewInt64(tableName, "tenant_id")
	_sysUserCredential.UserID = field.NewInt64(tableName, "user_id")
	_sysUserCredential.IdentityType = field.NewString(tableName, "identity_type")
	_sysUserCredential.Identifier = field.NewString(tableName, "identifier")
	_sysUserCredential.CredentialType = field.NewString(tableName, "credential_type")
	_sysUserCredential.Credential = field.NewString(tableName, "credential")
	_sysUserCredential.IsPrimary = field.NewBool(tableName, "is_primary")
	_sysUserCredential.Status = field.NewString(tableName, "status")
	_sysUserCredential.ExtraInfo = field.NewString(tableName, "extra_info")
	_sysUserCredential.Provider = field.NewString(tableName, "provider")
	_sysUserCredential.ProviderAccountID = field.NewString(tableName, "provider_account_id")
	_sysUserCredential.ActivateTokenHash = field.NewString(tableName, "activate_token_hash")
	_sysUserCredential.ActivateTokenExpiresAt = field.NewTime(tableName, "activate_token_expires_at")
	_sysUserCredential.ActivateTokenUsedAt = field.NewTime(tableName, "activate_token_used_at")
	_sysUserCredential.ResetTokenHash = field.NewString(tableName, "reset_token_hash")
	_sysUserCredential.ResetTokenExpiresAt = field.NewTime(tableName, "reset_token_expires_at")
	_sysUserCredential.ResetTokenUsedAt = field.NewTime(tableName, "reset_token_used_at")

	_sysUserCredential.fillFieldMap()

	return _sysUserCredential
}

type sysUserCredential struct {
	sysUserCredentialDo

	ALL                    field.Asterisk
	ID                     field.Int64  // id
	CreatedAt              field.Time   // 创建时间
	UpdatedAt              field.Time   // 更新时间
	DeletedAt              field.Field  // 删除时间
	TenantID               field.Int64  // 租户ID
	UserID                 field.Int64  // 关联主表的用户ID
	IdentityType           field.String // 认证方式类型
	Identifier             field.String // 身份唯一标识符
	CredentialType         field.String // 凭证类型
	Credential             field.String // 凭证
	IsPrimary              field.Bool   // 是否主认证方式
	Status                 field.String // 凭证状态
	ExtraInfo              field.String // 扩展信息
	Provider               field.String // 第三方平台标识
	ProviderAccountID      field.String // 第三方平台的账号唯一ID
	ActivateTokenHash      field.String // 激活令牌哈希（不要存明文）
	ActivateTokenExpiresAt field.Time   // 激活令牌到期时间
	ActivateTokenUsedAt    field.Time   // 激活令牌使用时间，单次使用时记录
	ResetTokenHash         field.String // 重置密码令牌哈希（不要存明文）
	ResetTokenExpiresAt    field.Time   // 重置令牌到期时间
	ResetTokenUsedAt       field.Time   // 重置令牌使用时间

	fieldMap map[string]field.Expr
}

func (s sysUserCredential) Table(newTableName string) *sysUserCredential {
	s.sysUserCredentialDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sysUserCredential) As(alias string) *sysUserCredential {
	s.sysUserCredentialDo.DO = *(s.sysUserCredentialDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sysUserCredential) updateTableName(table string) *sysUserCredential {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.DeletedAt = field.NewField(table, "deleted_at")
	s.TenantID = field.NewInt64(table, "tenant_id")
	s.UserID = field.NewInt64(table, "user_id")
	s.IdentityType = field.NewString(table, "identity_type")
	s.Identifier = field.NewString(table, "identifier")
	s.CredentialType = field.NewString(table, "credential_type")
	s.Credential = field.NewString(table, "credential")
	s.IsPrimary = field.NewBool(table, "is_primary")
	s.Status = field.NewString(table, "status")
	s.ExtraInfo = field.NewString(table, "extra_info")
	s.Provider = field.NewString(table, "provider")
	s.ProviderAccountID = field.NewString(table, "provider_account_id")
	s.ActivateTokenHash = field.NewString(table, "activate_token_hash")
	s.ActivateTokenExpiresAt = field.NewTime(table, "activate_token_expires_at")
	s.ActivateTokenUsedAt = field.NewTime(table, "activate_token_used_at")
	s.ResetTokenHash = field.NewString(table, "reset_token_hash")
	s.ResetTokenExpiresAt = field.NewTime(table, "reset_token_expires_at")
	s.ResetTokenUsedAt = field.NewTime(table, "reset_token_used_at")

	s.fillFieldMap()

	return s
}

func (s *sysUserCredential) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sysUserCredential) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 21)
	s.fieldMap["id"] = s.ID
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["deleted_at"] = s.DeletedAt
	s.fieldMap["tenant_id"] = s.TenantID
	s.fieldMap["user_id"] = s.UserID
	s.fieldMap["identity_type"] = s.IdentityType
	s.fieldMap["identifier"] = s.Identifier
	s.fieldMap["credential_type"] = s.CredentialType
	s.fieldMap["credential"] = s.Credential
	s.fieldMap["is_primary"] = s.IsPrimary
	s.fieldMap["status"] = s.Status
	s.fieldMap["extra_info"] = s.ExtraInfo
	s.fieldMap["provider"] = s.Provider
	s.fieldMap["provider_account_id"] = s.ProviderAccountID
	s.fieldMap["activate_token_hash"] = s.ActivateTokenHash
	s.fieldMap["activate_token_expires_at"] = s.ActivateTokenExpiresAt
	s.fieldMap["activate_token_used_at"] = s.ActivateTokenUsedAt
	s.fieldMap["reset_token_hash"] = s.ResetTokenHash
	s.fieldMap["reset_token_expires_at"] = s.ResetTokenExpiresAt
	s.fieldMap["reset_token_used_at"] = s.ResetTokenUsedAt
}

func (s sysUserCredential) clone(db *gorm.DB) sysUserCredential {
	s.sysUserCredentialDo.ReplaceDB(db)
	return s
}

type sysUserCredentialDo struct{ gen.DO }

type ISysUserCredentialDo interface {
	gen.SubQuery
	Debug() ISysUserCredentialDo
	WithContext(ctx context.Context) ISysUserCredentialDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISysUserCredentialDo
	Not(conds ...gen.Condition) ISysUserCredentialDo
	Or(conds ...gen.Condition) ISysUserCredentialDo
	Select(conds ...field.Expr) ISysUserCredentialDo
	Where(conds ...gen.Condition) ISysUserCredentialDo
	Order(conds ...field.Expr) ISysUserCredentialDo
	Distinct(cols ...field.Expr) ISysUserCredentialDo
	Omit(cols ...field.Expr) ISysUserCredentialDo
	Join(table schema.Tabler, on ...field.Expr) ISysUserCredentialDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISysUserCredentialDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISysUserCredentialDo
	Group(cols ...field.Expr) ISysUserCredentialDo
	Having(conds ...gen.Condition) ISysUserCredentialDo
	Limit(limit int) ISysUserCredentialDo
	Offset(offset int) ISysUserCredentialDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISysUserCredentialDo
	Unscoped() ISysUserCredentialDo
	Create(values ...*model.SysUserCredential) error
	CreateInBatches(values []*model.SysUserCredential, batchSize int) error
	Save(values ...*model.SysUserCredential) error
	First() (*model.SysUserCredential, error)
	Take() (*model.SysUserCredential, error)
	Last() (*model.SysUserCredential, error)
	Find() ([]*model.SysUserCredential, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysUserCredential, err error)
	FindInBatches(result *[]*model.SysUserCredential, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SysUserCredential) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISysUserCredentialDo
	Assign(attrs ...field.AssignExpr) ISysUserCredentialDo
	Joins(fields ...field.RelationField) ISysUserCredentialDo
	Preload(fields ...field.RelationField) ISysUserCredentialDo
	FirstOrInit() (*model.SysUserCredential, error)
	FirstOrCreate() (*model.SysUserCredential, error)
	FindByPage(offset int, limit int) (result []*model.SysUserCredential, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISysUserCredentialDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s sysUserCredentialDo) Debug() ISysUserCredentialDo {
	return s.withDO(s.DO.Debug())
}

func (s sysUserCredentialDo) WithContext(ctx context.Context) ISysUserCredentialDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sysUserCredentialDo) ReadDB() ISysUserCredentialDo {
	return s.Clauses(dbresolver.Read)
}

func (s sysUserCredentialDo) WriteDB() ISysUserCredentialDo {
	return s.Clauses(dbresolver.Write)
}

func (s sysUserCredentialDo) Clauses(conds ...clause.Expression) ISysUserCredentialDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sysUserCredentialDo) Returning(value interface{}, columns ...string) ISysUserCredentialDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sysUserCredentialDo) Not(conds ...gen.Condition) ISysUserCredentialDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sysUserCredentialDo) Or(conds ...gen.Condition) ISysUserCredentialDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sysUserCredentialDo) Select(conds ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sysUserCredentialDo) Where(conds ...gen.Condition) ISysUserCredentialDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sysUserCredentialDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ISysUserCredentialDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s sysUserCredentialDo) Order(conds ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sysUserCredentialDo) Distinct(cols ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sysUserCredentialDo) Omit(cols ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sysUserCredentialDo) Join(table schema.Tabler, on ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sysUserCredentialDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sysUserCredentialDo) RightJoin(table schema.Tabler, on ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sysUserCredentialDo) Group(cols ...field.Expr) ISysUserCredentialDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sysUserCredentialDo) Having(conds ...gen.Condition) ISysUserCredentialDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sysUserCredentialDo) Limit(limit int) ISysUserCredentialDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sysUserCredentialDo) Offset(offset int) ISysUserCredentialDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sysUserCredentialDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISysUserCredentialDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sysUserCredentialDo) Unscoped() ISysUserCredentialDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sysUserCredentialDo) Create(values ...*model.SysUserCredential) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sysUserCredentialDo) CreateInBatches(values []*model.SysUserCredential, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sysUserCredentialDo) Save(values ...*model.SysUserCredential) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sysUserCredentialDo) First() (*model.SysUserCredential, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUserCredential), nil
	}
}

func (s sysUserCredentialDo) Take() (*model.SysUserCredential, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUserCredential), nil
	}
}

func (s sysUserCredentialDo) Last() (*model.SysUserCredential, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUserCredential), nil
	}
}

func (s sysUserCredentialDo) Find() ([]*model.SysUserCredential, error) {
	result, err := s.DO.Find()
	return result.([]*model.SysUserCredential), err
}

func (s sysUserCredentialDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysUserCredential, err error) {
	buf := make([]*model.SysUserCredential, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sysUserCredentialDo) FindInBatches(result *[]*model.SysUserCredential, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sysUserCredentialDo) Attrs(attrs ...field.AssignExpr) ISysUserCredentialDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sysUserCredentialDo) Assign(attrs ...field.AssignExpr) ISysUserCredentialDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sysUserCredentialDo) Joins(fields ...field.RelationField) ISysUserCredentialDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sysUserCredentialDo) Preload(fields ...field.RelationField) ISysUserCredentialDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sysUserCredentialDo) FirstOrInit() (*model.SysUserCredential, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUserCredential), nil
	}
}

func (s sysUserCredentialDo) FirstOrCreate() (*model.SysUserCredential, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUserCredential), nil
	}
}

func (s sysUserCredentialDo) FindByPage(offset int, limit int) (result []*model.SysUserCredential, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sysUserCredentialDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sysUserCredentialDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sysUserCredentialDo) Delete(models ...*model.SysUserCredential) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sysUserCredentialDo) withDO(do gen.Dao) *sysUserCredentialDo {
	s.DO = *do.(*gen.DO)
	return s
}
